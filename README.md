# DesignPattern

## 设计原则

### 依赖倒置原则
    (1) 高层模块不依赖底层模块，二者都应该依赖抽象
    (2) 抽象不依赖实现细节，实现细节应该依赖于抽象

### 开放封闭原则
    (1) 对拓展开放，对更改封闭
    (2) 类模块应该是可拓展的，但它也是不可修改的
    (3) 在定义好接口之后就尽可能保证接口层的稳定

### 单一职责原则
    (1) 一个类应该仅有一个引起他变化的原因
    (2) 变化的方向隐含类的责任
    (3) 如果类中变化的部分过多，最终导致会修改接口部分，也就违反了第二原则。

### Liskov替换原则
    (1) 子类必须能够替换他们的基类
    (2) 继承表达类型的抽象


### 接口隔离原则
    (1) 不应该“强迫”客户程序依赖他们不用的方法
    (2) 接口应该小而完备
    (3) 设计对象时应该明确对象的功能，然后做出相应的接口，其余的方法应该全部隐藏


### 优先使用对象组合，而不是类继承
    (1) 白箱复用 (类继承)：将父类的全部内容暴露给子类
    (2) 黑箱复用 (对象组合)：只暴露想暴露的部分，其余的内容对其类不可见
    (3) 继承在某种程度上破坏了封装性，子类父类耦合度高
    (4) 对象组合则只要求被组合的对象具有良好的定义的接口


### 封装变化点
    (1) 使用封装来创建对象之间的分界层
    (2) 可以在变化的一侧进行修改，而不会对另一侧产生不良影响，从而达到层次间的松耦合


### 针对接口编程，而不是针对实现编程
    (1) 不将变量类型声明为某个特定类型的具体类，而是声明为某个接口
    (2) 客户程序无需知道对象的具体类型，只需要知道对象所具有的接口
    (3) 减少系统中各部分的依赖关系，从而实现”高内聚，松耦合“的类型设计方案

## 设计模式

### 创建型模式

#### 工厂方法模式 

#### 抽象工厂模式 

#### 生成器模式 

#### 原型模式 

#### 单例模式 

### 结构型模式

#### 适配器模式 

#### 桥接模式 

#### 组合模式 

#### 装饰模式 

#### 外观模式 

#### 享元模式 

#### 代理模式 

### 行为模式

#### 责任链模式 

#### 命令模式 

#### 中介者模式 

#### 观察者模式 

#### 备忘录模式 

#### 状态模式 

#### 策略模式 

#### 迭代器模式 

#### 访问者模式 

#### 模板方法模式 
