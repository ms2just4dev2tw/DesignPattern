/**
 * <h1>作用范围</h1>
 * <h2>1，类行为型</h2>
 * 类模式处理类和子类的关系。这些关系是通过继承建立的，在编译时就已经建立了。
 * <h2>2，对象行为型</h2>
 * 对象模式处理对象间的关系。这些关系是可以变化的，更具有动态性。
 * <p>
 * 类模式只指那些集中于处理类间关系的模式，大多数模式是对象行为型。
 * 
 * <h1>设计原则</h1>
 * <h2>1，依赖倒置原则</h2>
 * <ul>
 * 		<li>高层模块不依赖底层模块，二者都应该依赖抽象</li>
 * 		<li>抽象不依赖实现细节，实现细节应该依赖于抽象</li>
 * </ul>
 * 
 * <h2>2，开放封闭原则</h2>
 * <ul>
 * 		<li>对拓展开放，对更改封闭</li>
 * 		<li>类模块应该是可拓展的，但它也是不可修改的</li>
 * 		<li>在定义好接口之后就尽可能保证接口层的稳定</li>
 * </ul>
 * 
 * <h2>3，单一职责原则</h2>
 * <ul>
 * 		<li>一个类应该仅有一个引起他变化的原因</li>
 * 		<li>变化的方向隐含类的责任</li>
 * 		<li>如果类中变化的部分过多，最终导致会修改接口部分，也就违反了第二原则。</li>
 * </ul>
 * 
 * <h2>4，Liskov替换原则</h2>
 * <ul>
 * 		<li>子类必须能够替换他们的基类</li>
 * 		<li>继承表达类型的抽象</li>
 * </ul>
 * 
 * <h2>5，接口隔离原则</h2>
 * <ul>
 * 		<li>不应该“强迫”客户程序依赖他们不用的方法</li>
 * 		<li>接口应该小而完备</li>
 * 		<li>设计对象时应该明确对象的功能，然后做出相应的接口，其余的方法应该全部隐藏</li>
 * </ul>
 * 
 * <h2>6，优先使用对象组合，而不是类继承</h2>
 * <ul>
 * 		<li>白箱复用 (类继承)：将父类的全部内容暴露给子类</li>
 * 		<li>黑箱复用 (对象组合)：只暴露想暴露的部分，其余的内容对其类不可见</li>
 * 		<li>继承在某种程度上破坏了封装性，子类父类耦合度高</li>
 *  	<li>对象组合则只要求被组合的对象具有良好的定义的接口</li>
 * </ul>
 * 
 * <h2>7，封装变化点</h2>
 * <ul>
 * 		<li>使用封装来创建对象之间的分界层</li>
 * 		<li>可以在变化的一侧进行修改，而不会对另一侧产生不良影响，从而达到层次间的松耦合</li>
 * </ul>
 * 
 * <h2>8，针对接口编程，而不是针对实现编程</h2>
 * <ul>
 * 		<li>不将变量类型声明为某个特定类型的具体类，而是声明为某个接口</li>
 * 		<li>客户程序无需知道对象的具体类型，只需要知道对象所具有的接口</li>
 * 		<li>减少系统中各部分的依赖关系，从而实现”高内聚，松耦合“的类型设计方案</li>
 * </ul>
 */
package org.gof;
